<!DOCTYPE html>
<html lang="ar" dir="rtl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ | SafeWatch</title>
    <link rel="stylesheet" href="css/style.css">
    <script src="/socket.io/socket.io.js"></script>
    <style>
        body,
        html {
            height: 100%;
            overflow: hidden;
            background: black;
        }

        #localVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .monitor-status {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 10;
        }

        #dim-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            opacity: 0;
            pointer-events: none;
            /* Let clicks pass through if needed, or handle taps to wake */
            z-index: 999;
            transition: opacity 0.5s;
        }
    </style>
</head>

<body>

    <div id="permission-overlay"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #0f172a; color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 2000; text-align: center; padding: 20px;">
        <ion-icon name="videocam" style="font-size: 4rem; color: #3b82f6; margin-bottom: 20px;"></ion-icon>
        <h2 style="margin-bottom: 10px;">Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§</h2>
        <p style="margin-bottom: 30px; font-size: 1.1rem; color: #94a3b8;">Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡ Ù„Ù„Ø¨Ø¯Ø¡</p>
        <button id="start-btn" class="btn"
            style="background: #10b981; border: none; padding: 15px 40px; border-radius: 50px; color: white; font-size: 1.2rem; font-weight: bold; cursor: pointer;">
            Ø­Ø³Ù†Ø§Ù‹ Ù„Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø±
        </button>
    </div>

    <!-- Added webkit-playsinline for iOS compatibility -->
    <video id="localVideo" autoplay playsinline webkit-playsinline muted
        style="width: 100%; height: 100%; object-fit: cover;"></video>

    <!-- Debug Log Container -->
    <div id="debug-log"
        style="position: absolute; top: 10px; left: 10px; z-index: 5000; color: #0f0; font-size: 10px; background: rgba(0,0,0,0.7); max-height: 200px; overflow-y: auto; pointer-events: none; text-align: left; direction: ltr;">
        Log started...<br>
    </div>

    <!-- Restart Button -->
    <button id="restart-cam-btn"
        style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 5001; background: red; color: white; border: none; padding: 20px 40px; border-radius: 10px; font-size: 1.2rem; display: none; cursor: pointer;">
        Ø§Ø¶ØºØ· Ù‡Ù†Ø§ Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ (Force Start)
    </button>

    <div class="monitor-status" id="status-text" style="transition: opacity 0.5s;">
        Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±...
    </div>

    <div id="dim-overlay" style="opacity: 0;"></div>

    <script type="module" src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"></script>
    <script>
        // Log function for on-screen debugging
        function log(msg) {
            console.log(msg);
            const d = document.getElementById('debug-log');
            d.innerHTML += msg + "<br>";
            d.scrollTop = d.scrollHeight;
        }

        const socket = io();
        const urlParams = new URLSearchParams(window.location.search);
        const roomId = urlParams.get('session');
        const localVideo = document.getElementById('localVideo');
        const permissionOverlay = document.getElementById('permission-overlay');
        const dimOverlay = document.getElementById('dim-overlay');
        const statusText = document.getElementById('status-text');
        const restartBtn = document.getElementById('restart-cam-btn');

        let peerConnection;
        let localStream;
        let currentFacingMode = 'environment';
        let wakeLock = null;
        let errorCount = 0;

        const config = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        if (!roomId) {
            alert('No Session ID');
            window.location.href = '/';
        }

        restartBtn.addEventListener('click', async () => {
            restartBtn.style.display = 'none';
            log("User clicked Force Start");
            // Must call play() directly in user event
            if (localVideo.srcObject) {
                try {
                    await localVideo.play();
                    log("Video playing after manual click!");
                    statusText.innerText = "Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ ØªØ¹Ù…Ù„ Ø§Ù„Ø¢Ù†.";
                    if (statusText.innerHTML.includes("ÙˆØ¶Ø¹ Ø§Ù„ØªÙˆØ§ÙÙ‚")) {
                        startCanvasStreaming();
                    }
                } catch (e) {
                    log("Manual play failed: " + e.message);
                }
            } else {
                await getCamera(currentFacingMode);
            }
        });

        // 1. Wake Lock (Keep Screen Alive)
        async function requestWakeLock() {
            try {
                wakeLock = await navigator.wakeLock.request('screen');
                log('Wake Lock is active!');
            } catch (err) {
                log(`${err.name}, ${err.message}`);
            }
        }

        // 2. Custom Permission Button Handler
        document.getElementById('start-btn').addEventListener('click', async () => {
            permissionOverlay.style.display = 'none';
            log("Permission granted. Starting camera...");
            await getCamera(currentFacingMode);
            await requestWakeLock(); // Keep screen on

            socket.emit('join-room', roomId, 'monitor');
            statusText.innerText = "Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø¬Ø§Ù‡Ø²Ø©.";
        });

        async function getCamera(facingMode = 'environment') {
            log(`Getting camera (${facingMode})...`);
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                log("Browser does not support camera access (ensure HTTPS).");
                statusText.innerText = "Ø§Ù„Ù…ØªØµÙØ­ Ù„Ø§ ÙŠØ¯Ø¹Ù… Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§ (ØªØ£ÙƒØ¯ Ù…Ù† HTTPS).";
                return;
            }

            try {
                if (localStream) {
                    log("Stopping existing stream tracks.");
                    localStream.getTracks().forEach(track => track.stop());
                }

                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: facingMode,
                        width: { ideal: 640 }, // Lower res for broader compatibility
                        height: { ideal: 480 }
                    },
                    audio: false // Disable audio for now to reduce complexity/prevent feedback
                });

                log("Stream acquired. Tracks: " + stream.getTracks().length);

                localStream = stream;
                localVideo.srcObject = stream;

                // Explicitly try to play
                try {
                    await localVideo.play();
                    log("Video.play() success");
                } catch (e) {
                    log("Video.play() error: " + e.message);
                    log("SHOWING FORCE START BUTTON");
                    restartBtn.style.display = 'block';
                }

                // Refresh connection if active
                if (peerConnection) {
                    log("Peer connection active, replacing video track.");
                    const videoTrack = stream.getVideoTracks()[0];
                    const sender = peerConnection.getSenders().find(s => s.track.kind === 'video');
                    if (sender) sender.replaceTrack(videoTrack);
                }

                return stream;
            } catch (err) {
                log("Camera Error: " + err.message);

                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                    statusText.innerHTML = `
                        <div style="background: rgba(255,0,0,0.8); padding: 20px; border-radius: 10px;">
                            <h3>â›” ØªÙ… Ø±ÙØ¶ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§</h3>
                            <p>ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ù…ÙˆÙ‚Ø¹ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§:</p>
                            <ol style="text-align: right; margin-top: 10px; line-height: 1.8;">
                                <li>Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø£ÙŠÙ‚ÙˆÙ†Ø© Ø§Ù„Ù‚ÙÙ„ ğŸ”’ Ø£Ùˆ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨Ø¬Ø§Ù†Ø¨ Ø§Ù„Ø±Ø§Ø¨Ø· ÙÙŠ Ø§Ù„Ø£Ø¹Ù„Ù‰.</li>
                                <li>Ø§Ø®ØªØ± "Ø§Ù„Ø£Ø°ÙˆÙ†Ø§Øª" (Permissions).</li>
                                <li>ÙØ¹Ù„ Ø®ÙŠØ§Ø± Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ ğŸ“·.</li>
                                <li>Ø§Ø¹Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©.</li>
                            </ol>
                        </div>
                    `;
                    statusText.style.background = "transparent";
                } else {
                    statusText.innerText = "Error: " + err.message;
                    restartBtn.style.display = 'block';
                    restartBtn.innerText = "ÙØ´Ù„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§. Ø§Ø¶ØºØ· Ù„Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰";
                }
            }
        }

        // Socket Events
        let iceCandidatesQueue = [];

        socket.on('offer', async (payload) => {
            console.log("Received Offer");
            statusText.innerText = "ØªÙ… Ø§Ù„Ø§ØªØµØ§Ù„! Ø§Ù„Ø¨Ø« Ù…Ø¨Ø§Ø´Ø± Ø§Ù„Ø¢Ù†.";
            statusText.style.background = "green";

            peerConnection = new RTCPeerConnection(config);

            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('ice-candidate', { roomId, candidate: event.candidate });
                }
            };

            await peerConnection.setRemoteDescription(new RTCSessionDescription(payload.sdp));

            while (iceCandidatesQueue.length > 0) {
                await peerConnection.addIceCandidate(new RTCIceCandidate(iceCandidatesQueue.shift()));
            }

            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);

            socket.emit('answer', { roomId, sdp: answer });

            startBatteryUpdates();
        });

        socket.on('ice-candidate', async (payload) => {
            if (peerConnection && peerConnection.remoteDescription) {
                await peerConnection.addIceCandidate(new RTCIceCandidate(payload.candidate));
            } else {
                iceCandidatesQueue.push(payload.candidate);
            }
        });

        socket.on('control-command', async (payload) => {
            console.log("Command received:", payload.command);

            const videoTrack = localStream ? localStream.getVideoTracks()[0] : null;

            if (payload.command === 'switch-camera') {
                currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
                await getCamera(currentFacingMode);
            }

            if (payload.command === 'toggle-torch') {
                if (videoTrack) {
                    const capabilities = videoTrack.getCapabilities();
                    if (capabilities.torch) {
                        try {
                            const currentSettings = videoTrack.getSettings();
                            await videoTrack.applyConstraints({ advanced: [{ torch: !currentSettings.torch }] });
                        } catch (e) {
                            log("Torch error: " + e.message);
                        }
                    } else {
                        log("Torch not supported on this camera/device.");
                        statusText.innerText = "Ø§Ù„ÙÙ„Ø§Ø´ ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ… ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§";
                        setTimeout(() => statusText.innerText = "Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ ØªØ¹Ù…Ù„", 3000);
                    }
                }
            }

            if (payload.command === 'set-zoom') {
                if (videoTrack) {
                    const capabilities = videoTrack.getCapabilities();
                    if (capabilities.zoom) {
                        try {
                            await videoTrack.applyConstraints({ advanced: [{ zoom: payload.value }] });
                        } catch (e) {
                            log("Zoom error: " + e.message);
                        }
                    }
                }
            }

            if (payload.command === 'screen-dim') {
                toggleStealthMode();
            }
            if (payload.command === 'start-compatibility-mode') {
                // Determine speed based on payload
                const interval = payload.interval || 100; // Default 100ms (Video-like)
                startCanvasStreaming(interval);
            }
            if (payload.command === 'stop-compatibility-mode') {
                stopCanvasStreaming();
            }
        });

        // Helper: Stealth Mode
        function toggleStealthMode() {
            const isHidden = dimOverlay.style.opacity === '1';
            dimOverlay.style.opacity = isHidden ? '0' : '1';
            // Also toggle status text visibility
            statusText.style.display = isHidden ? 'block' : 'none';
        }

        // Add a click listener to the dim overlay to wake it up locally
        dimOverlay.addEventListener('click', () => {
            toggleStealthMode();
        });

        // --- SNAPSHOT / COMPATIBILITY MODE ---
        let canvasInterval = null;
        let framesSent = 0;
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        function startCanvasStreaming(intervalMs) {
            if (canvasInterval) clearInterval(canvasInterval);

            const isSnapshot = intervalMs > 1000;
            statusText.innerHTML = isSnapshot ?
                `ÙˆØ¶Ø¹ Ø§Ù„Ù„Ù‚Ø·Ø§Øª ÙŠØ¹Ù…Ù„.<br>ØµÙˆØ±Ø© ÙƒÙ„ ${intervalMs / 1000} Ø«Ø§Ù†ÙŠØ©` :
                "ÙˆØ¶Ø¹ Ø§Ù„ØªÙˆØ§ÙÙ‚ ÙŠØ¹Ù…Ù„.<br>Ø¬Ø§Ø±ÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø·Ø§Ø±Ø§Øª...";

            statusText.style.background = "#f59e0b";

            canvas.width = 640;
            canvas.height = 480;

            canvasInterval = setInterval(async () => {
                try {
                    if (localVideo.readyState >= 2) {
                        ctx.drawImage(localVideo, 0, 0, canvas.width, canvas.height);
                        const quality = isSnapshot ? 0.6 : 0.3; // Higher quality for slow snapshots
                        const data = canvas.toDataURL('image/jpeg', quality);
                        socket.emit('stream-data', { roomId, image: data });

                        framesSent++;
                        if (framesSent % 5 === 0) {
                            statusText.innerHTML = isSnapshot ?
                                `ÙˆØ¶Ø¹ Ø§Ù„Ù„Ù‚Ø·Ø§Øª: ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ${framesSent} ØµÙˆØ±Ø©` :
                                `ÙˆØ¶Ø¹ Ø§Ù„ØªÙˆØ§ÙÙ‚: ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ${framesSent} Ø¥Ø·Ø§Ø±`;
                        }
                    } else {
                        localVideo.play().catch(e => { });
                    }
                } catch (e) {
                    console.error(e);
                }
            }, intervalMs);
        }

        function stopCanvasStreaming() {
            if (canvasInterval) {
                clearInterval(canvasInterval);
                canvasInterval = null;
                statusText.innerText = "ØªÙ… Ø¥ÙŠÙ‚Ø§Ù ÙˆØ¶Ø¹ Ø§Ù„ØªÙˆØ§ÙÙ‚.";
                statusText.style.background = "var(--primary)";
            }
        }

        // Expose for debugging if needed
        window.sendTestFrame = () => {
            canvas.width = 320;
            canvas.height = 240;
            ctx.fillStyle = "red";
            ctx.fillRect(0, 0, 320, 240);
            ctx.fillStyle = "white";
            ctx.font = "30px Arial";
            ctx.fillText("TEST FRAME", 50, 120);
            const data = canvas.toDataURL('image/jpeg', 0.5);
            socket.emit('stream-data', { roomId, image: data });
            alert("ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© Ø­Ù…Ø±Ø§Ø¡ Ø§Ø®ØªØ¨Ø§Ø±ÙŠØ©. ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø´Ø§Ø´Ø© Ø§Ù„Ø£Ø®Ø±Ù‰.");
        };

        // Battery API
        function startBatteryUpdates() {
            if ('getBattery' in navigator) {
                navigator.getBattery().then(battery => {
                    sendBattery(battery);
                    battery.addEventListener('levelchange', () => sendBattery(battery));
                    battery.addEventListener('chargingchange', () => sendBattery(battery));
                });
            } else {
                console.log("Battery API not supported on this device.");
            }
        }

        function sendBattery(battery) {
            const level = Math.round(battery.level * 100);
            socket.emit('status-update', {
                roomId,
                type: 'battery',
                level: level,
                charging: battery.charging
            });
        }
    </script>
</body>

</html>